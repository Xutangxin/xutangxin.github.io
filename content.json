{"meta":{"title":"xutangxin's blog","subtitle":"","description":"","author":"Tangxin Xu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"简述JS浅拷贝和深拷贝","slug":"简述JS浅拷贝和深拷贝","date":"2021-05-03T01:55:05.000Z","updated":"2021-05-03T01:55:05.861Z","comments":true,"path":"2021/05/03/简述JS浅拷贝和深拷贝/","link":"","permalink":"http://example.com/2021/05/03/%E7%AE%80%E8%BF%B0JS%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JS 反转数组的几种方法","slug":"JS-反转数组的几种方法","date":"2021-05-03T01:50:04.000Z","updated":"2021-05-03T01:50:33.630Z","comments":true,"path":"2021/05/03/JS-反转数组的几种方法/","link":"","permalink":"http://example.com/2021/05/03/JS-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122let arr = [1, 2, 3, 4, 5];// 方法1，影响原数组// console.log(arr.reverse());// 方法2，不影响原数组let reverseArr = arr.slice().reverse();console.log(arr);console.log(reverseArr);// 方法3，不影响原数组let reverseArr2 = [...arr].reverse();console.log(arr);console.log(reverseArr2);// 方法4，不使用reverse实现反转数组let reverseArr3 = [];for (let i = arr.length - 1; i &gt;= 0; i--) &#123; reverseArr3.push(arr[i]);&#125;console.log(arr);console.log(reverseArr3);","categories":[],"tags":[]},{"title":"简述函数节流和防抖","slug":"简述函数节流和防抖","date":"2021-05-02T12:40:05.000Z","updated":"2021-05-02T13:02:01.307Z","comments":true,"path":"2021/05/02/简述函数节流和防抖/","link":"","permalink":"http://example.com/2021/05/02/%E7%AE%80%E8%BF%B0%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/","excerpt":"","text":"为什么需要函数节流和防抖频繁执行dom操作，资源加载等行为，可能会导致UI卡顿或浏览器崩溃如果每次执行事件就会触发函数，这样的做法不仅没有意义，还会浪费资源 函数节流每隔一定的时间才能调用函数，而不是每次触发事件就执行一次，这样会减少资源的浪费（连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。） 函数防抖当事件触发完一定时间后，在这个时间间隔内没有事件再次触发，就认为该事件触发完成了，此时可以执行函数（触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。） 代码示例html: 12&lt;button id=&quot;btn&quot;&gt;节流&lt;/button&gt;&lt;button id=&quot;btn2&quot;&gt;防抖&lt;/button&gt; js: 12345678910111213141516171819202122232425262728293031323334353637//定义节流函数function Throttle(fn, delay) &#123; let lastTime = 0; return function () &#123;//为什么要用闭包？ let nowTime = Date.now(); if (nowTime - lastTime &gt; delay) &#123; fn.apply(this);//使用apply保证this指向正确 lastTime = Date.now(); &#125; &#125;&#125;//定义被节流的函数function fn() &#123; console.log(&#x27;节流&#x27;);&#125;//响应事件，触发节流函数btn.onclick = Throttle(fn, 1000);// 定义防抖函数function debounce(fn, delay) &#123; let timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this) &#125;,delay); &#125;&#125;//定义被防抖的函数function fn2()&#123; console.log(&#x27;防抖&#x27;);&#125;//响应事件，触发防抖函数document.querySelector(&#x27;#btn2&#x27;).onclick=debounce(fn2,3000);","categories":[],"tags":[]},{"title":"JS 数组去重的几种方法","slug":"JS-数组去重的几种方法","date":"2021-05-01T08:47:54.000Z","updated":"2021-05-02T13:02:09.457Z","comments":true,"path":"2021/05/01/JS-数组去重的几种方法/","link":"","permalink":"http://example.com/2021/05/01/JS-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031// let arr=[1,2,3,3,3,4,4,5];let arr=[0,0,1,1,1,2,2,3,3,4];// 方法1 最简单let newArr=[...new Set(arr)];console.log(newArr);// 方法2 使用indexOflet newArr2=[];for(let i=0;i&lt;arr.length;i++)&#123; if(newArr2.indexOf(arr[i])===-1)&#123; newArr2.push(arr[i]); &#125;&#125;console.log(newArr2);// 方法3 使用includeslet newArr3=[];for(let i=0;i&lt;arr.length;i++)&#123; if(!newArr3.includes(arr[i]))&#123; newArr3.push(arr[i]); &#125;&#125;console.log(newArr3);// 方法4 使用filterlet newArr4=arr.filter((item,index,arr)=&gt;&#123; // 当前元素在原始数组中的第一个索引===当前索引值 return arr.indexOf(item,0)===index;&#125;);console.log(newArr4);","categories":[],"tags":[]},{"title":"JS中==和===的区别","slug":"JS中-和-的区别","date":"2021-04-17T04:10:09.000Z","updated":"2021-05-03T02:09:39.572Z","comments":true,"path":"2021/04/17/JS中-和-的区别/","link":"","permalink":"http://example.com/2021/04/17/JS%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"总的来说：==判断相等，===判断严格相等/全等==只判断数据的值是否相等，===先判断数据的类型是否相同，再判断数据的值是否相等 ==判断规则：两个基本数据类型比较：如果两个基本数据类型不同，会先把它们转换成数值类型，再进行比较基本数据类型和引用数据类型比较：先把对象转换成原始值，再按照以上规则进行比较两个引用类型比较：判断两者的引用地址是否相同NaN不等于任何操作数，甚至不等于它自身特殊情况： 1234null==undefined//trueNaN!=NaN//trueundefined==0//falsenull==0//false ===判断规则：先判断两者类型，只要类型不一致，直接返回false，类型相同的前提下，再判断值是否相等 尽量使用===，因为==不严谨","categories":[],"tags":[]},{"title":"JS中的变量类型转换","slug":"JS中变量类型隐式转换","date":"2021-04-17T04:01:23.000Z","updated":"2021-04-17T07:17:03.623Z","comments":true,"path":"2021/04/17/JS中变量类型隐式转换/","link":"","permalink":"http://example.com/2021/04/17/JS%E4%B8%AD%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"可能会出现类型转换的情况： if语句 逻辑语句 数学运算当数字和字符串相加时，js会把数字转换为字符串，然后拼接 ==详情参见JS中==和===的区别特殊情况：null==undefined结果为true","categories":[],"tags":[]}],"categories":[],"tags":[]}