{"meta":{"title":"xutangxin's blog","subtitle":"","description":"","author":"Tangxin Xu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"ES5和ES6中的继承","slug":"ES5和-ES6中的继承","date":"2021-05-05T07:30:37.000Z","updated":"2021-05-05T07:43:43.892Z","comments":true,"path":"2021/05/05/ES5和-ES6中的继承/","link":"","permalink":"http://example.com/2021/05/05/ES5%E5%92%8C-ES6%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"","text":"在ES5中是利用构造函数的形式来实现面向对象的，ES6新增了类（class）的概念，是ES5中构造函数形式的语法糖以下分别是ES5和ES6中的继承例子： ES5中的继承ES5中的继承有多种方式，这里以组合继承为例 123456789101112131415161718192021222324252627// 父类function Father(name) &#123; this.name = name; this.colors = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;purple&#x27;];&#125;// 父类的函数Father.prototype.sayName = function () &#123; console.log(this.name);&#125;Father.prototype.showHobby = function () &#123; console.log(&#x27;my hobby is watching TV&#x27;);&#125;// 子类function Son(name, age) &#123; // 继承父类的name属性 Father.call(this, name); // 定义子类自己的属性age this.age = age;&#125;// 继承父类的方法Son.prototype = new Father();Son.prototype.constructor = Son;// 定义自己的方法Son.prototype.sayAge = function () &#123; console.log(this.age);&#125; ES6中的继承123456789101112131415161718192021222324252627class Father &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHi() &#123; console.log(&#x27;hello I am &#x27; + this.name); &#125; say() &#123; return &#x27;我是父亲&#x27;; &#125;&#125;class Son extends Father &#123; constructor(name, age, hobby) &#123; // super实现继承父类构造函数 super(name, age); // 子类独有的属性hobby，需要单独写 this.hobby = hobby; &#125; sayHi() &#123; // super调用父类普通函数 console.log(super.say() + &#x27;的儿子&#x27;); console.log(&#x27;hello, my name is &#x27; + this.name); &#125;&#125;","categories":[],"tags":[]},{"title":"简述JS浅拷贝和深拷贝","slug":"简述JS浅拷贝和深拷贝","date":"2021-05-03T01:55:05.000Z","updated":"2021-05-03T02:33:14.891Z","comments":true,"path":"2021/05/03/简述JS浅拷贝和深拷贝/","link":"","permalink":"http://example.com/2021/05/03/%E7%AE%80%E8%BF%B0JS%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"数据类型 基本数据类型数据直接存储到栈中 引用数据类型数据的引用存放在栈中，真实的数据存放在堆内存中 浅拷贝和深拷贝浅拷贝和深拷贝是只针对引用数据类型而言的，基本数据类型无所谓浅拷贝和深拷贝 浅拷贝当两个引用数据类型浅拷贝时，拷贝的只是引用，改变其中一个数据的值，另一个也会随之改变。两个数据的变化是联动的。 深拷贝创建另一个一摸一样的对象，新对象和原来的对象不共享内存，两个对象数据的变化不会联动 深拷贝实现1234567891011121314151617181920212223242526272829303132333435//数组深拷贝示例let arr = [&#x27;javascript&#x27;, &#x27;python&#x27;, &#x27;typescript&#x27;, &#x27;c&#x27;];let arr2 = [...arr];arr2[1] = &#x27;java&#x27;;console.log(arr);//[ &#x27;javascript&#x27;, &#x27;python&#x27;, &#x27;typescript&#x27;, &#x27;c&#x27; ]console.log(arr2);//[ &#x27;javascript&#x27;, &#x27;java&#x27;, &#x27;typescript&#x27;, &#x27;c&#x27; ]//对象深拷贝示例let obj = &#123; name: &#x27;xutangxin&#x27;, age: 22&#125;//深拷贝函数const deepCopy = (sourceObj) =&gt; &#123; const targetObj = Array.isArray(sourceObj) ? [] : &#123;&#125;; for (let key in sourceObj) &#123; if (sourceObj.hasOwnProperty(key)) &#123; //如果是引用类型，就递归复制 if (sourceObj[key] &amp;&amp; typeof sourceObj[key] === &#x27;object&#x27;) &#123; targetObj[key] = deepCopy(sourceObj[key]); &#125; else &#123; //如果是简单数据类型，就直接复制 targetObj[key] = sourceObj[key]; &#125; &#125; &#125; return targetObj;&#125;let obj2 = deepCopy(obj);console.log(obj, obj2);//&#123; name: &#x27;xutangxin&#x27;, age: 22 &#125; &#123; name: &#x27;xutangxin&#x27;, age: 22 &#125;obj2.name = &#x27;xuhu&#x27;;console.log(obj, obj2);//&#123; name: &#x27;xutangxin&#x27;, age: 22 &#125; &#123; name: &#x27;xuhu&#x27;, age: 22 &#125;","categories":[],"tags":[]},{"title":"JS 反转数组的几种方法","slug":"JS-反转数组的几种方法","date":"2021-05-03T01:50:04.000Z","updated":"2021-05-03T01:50:33.630Z","comments":true,"path":"2021/05/03/JS-反转数组的几种方法/","link":"","permalink":"http://example.com/2021/05/03/JS-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122let arr = [1, 2, 3, 4, 5];// 方法1，影响原数组// console.log(arr.reverse());// 方法2，不影响原数组let reverseArr = arr.slice().reverse();console.log(arr);console.log(reverseArr);// 方法3，不影响原数组let reverseArr2 = [...arr].reverse();console.log(arr);console.log(reverseArr2);// 方法4，不使用reverse实现反转数组let reverseArr3 = [];for (let i = arr.length - 1; i &gt;= 0; i--) &#123; reverseArr3.push(arr[i]);&#125;console.log(arr);console.log(reverseArr3);","categories":[],"tags":[]},{"title":"简述函数节流和防抖","slug":"简述函数节流和防抖","date":"2021-05-02T12:40:05.000Z","updated":"2021-05-02T13:02:01.307Z","comments":true,"path":"2021/05/02/简述函数节流和防抖/","link":"","permalink":"http://example.com/2021/05/02/%E7%AE%80%E8%BF%B0%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/","excerpt":"","text":"为什么需要函数节流和防抖频繁执行dom操作，资源加载等行为，可能会导致UI卡顿或浏览器崩溃如果每次执行事件就会触发函数，这样的做法不仅没有意义，还会浪费资源 函数节流每隔一定的时间才能调用函数，而不是每次触发事件就执行一次，这样会减少资源的浪费（连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。） 函数防抖当事件触发完一定时间后，在这个时间间隔内没有事件再次触发，就认为该事件触发完成了，此时可以执行函数（触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。） 代码示例html: 12&lt;button id=&quot;btn&quot;&gt;节流&lt;/button&gt;&lt;button id=&quot;btn2&quot;&gt;防抖&lt;/button&gt; js: 12345678910111213141516171819202122232425262728293031323334353637//定义节流函数function Throttle(fn, delay) &#123; let lastTime = 0; return function () &#123;//为什么要用闭包？ let nowTime = Date.now(); if (nowTime - lastTime &gt; delay) &#123; fn.apply(this);//使用apply保证this指向正确 lastTime = Date.now(); &#125; &#125;&#125;//定义被节流的函数function fn() &#123; console.log(&#x27;节流&#x27;);&#125;//响应事件，触发节流函数btn.onclick = Throttle(fn, 1000);// 定义防抖函数function debounce(fn, delay) &#123; let timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this) &#125;,delay); &#125;&#125;//定义被防抖的函数function fn2()&#123; console.log(&#x27;防抖&#x27;);&#125;//响应事件，触发防抖函数document.querySelector(&#x27;#btn2&#x27;).onclick=debounce(fn2,3000);","categories":[],"tags":[]},{"title":"JS 数组去重的几种方法","slug":"JS-数组去重的几种方法","date":"2021-05-01T08:47:54.000Z","updated":"2021-05-02T13:02:09.457Z","comments":true,"path":"2021/05/01/JS-数组去重的几种方法/","link":"","permalink":"http://example.com/2021/05/01/JS-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031// let arr=[1,2,3,3,3,4,4,5];let arr=[0,0,1,1,1,2,2,3,3,4];// 方法1 最简单let newArr=[...new Set(arr)];console.log(newArr);// 方法2 使用indexOflet newArr2=[];for(let i=0;i&lt;arr.length;i++)&#123; if(newArr2.indexOf(arr[i])===-1)&#123; newArr2.push(arr[i]); &#125;&#125;console.log(newArr2);// 方法3 使用includeslet newArr3=[];for(let i=0;i&lt;arr.length;i++)&#123; if(!newArr3.includes(arr[i]))&#123; newArr3.push(arr[i]); &#125;&#125;console.log(newArr3);// 方法4 使用filterlet newArr4=arr.filter((item,index,arr)=&gt;&#123; // 当前元素在原始数组中的第一个索引===当前索引值 return arr.indexOf(item,0)===index;&#125;);console.log(newArr4);","categories":[],"tags":[]},{"title":"JS中==和===的区别","slug":"JS中-和-的区别","date":"2021-04-17T04:10:09.000Z","updated":"2021-05-03T02:14:26.572Z","comments":true,"path":"2021/04/17/JS中-和-的区别/","link":"","permalink":"http://example.com/2021/04/17/JS%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"总的来说：==判断相等，===判断严格相等/全等==只判断数据的值是否相等，===先判断数据的类型是否相同，再判断数据的值是否相等 ==判断规则：两个基本数据类型比较：如果两个基本数据类型不同，会先把它们转换成数值类型，再进行比较基本数据类型和引用数据类型比较：先把对象转换成原始值，再按照以上规则进行比较两个引用类型比较：判断两者的引用地址是否相同NaN不等于任何操作数，甚至不等于它自身特殊情况：1234null == undefined//trueNaN != NaN//trueundefined == 0//falsenull == 0//false ===判断规则：先判断两者类型，只要类型不一致，直接返回false，类型相同的前提下，再判断值是否相等 尽量使用===，因为==不严谨","categories":[],"tags":[]},{"title":"JS中的变量类型转换","slug":"JS中变量类型隐式转换","date":"2021-04-17T04:01:23.000Z","updated":"2021-05-03T02:31:56.819Z","comments":true,"path":"2021/04/17/JS中变量类型隐式转换/","link":"","permalink":"http://example.com/2021/04/17/JS%E4%B8%AD%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"可能会出现类型转换的情况： if语句 逻辑语句 数学运算当数字和字符串相加时，js会把数字转换为字符串，然后拼接 ==详情参见’JS中==和===的区别’特殊情况：null==undefined结果为true","categories":[],"tags":[]}],"categories":[],"tags":[]}