{"meta":{"title":"xutangxin's blog","subtitle":"","description":"","author":"Tangxin Xu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"JS 判断数据类型","slug":"JS-判断数据类型","date":"2021-05-21T02:08:01.000Z","updated":"2021-05-21T02:32:38.441Z","comments":true,"path":"2021/05/21/JS-判断数据类型/","link":"","permalink":"http://example.com/2021/05/21/JS-%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"本文简述下判断js类型的三种方式 typeoftypeof 返回一个值的类型，对于基本数据类型，除了null都会返回正确的结果（null返回Object）当用typeof判断引用数据类型时，对于函数会返回Function，其余的会返回Object instanceofinstanceof 只能用来判断对象，它判断某一个对象是否是某个构造函数的实例例如： 1234const obj=&#123;&#125;;const arr=[];console.log(obj instanceof Object);//trueconsole.log(arr instanceof Array);//true Object.prototype.toStringtoString()是Object的原型方法，调用该方法，默认返回当前对象的 [[Class]]。这是一个内部属性，其格式为[object xxx]，其中xxx就是对象的类型该方法既可以判断简单数据类型，也可判断引用数据类型 123456console.log(Object.prototype.toString.call(&#x27;hello world&#x27;));//[object String]console.log(Object.prototype.toString.call(null));//[object Null]console.log(Object.prototype.toString.call(undefined));//[object Undefined]console.log(Object.prototype.toString.call([]));//[object Array]console.log(Object.prototype.toString.call(function () &#123; &#125;));//[object Function]console.log(Object.prototype.toString.call(&#123;&#125;));//[object Object]","categories":[],"tags":[]},{"title":"简述cookie, session和token","slug":"简述cookie session和token","date":"2021-05-15T09:18:14.000Z","updated":"2021-05-15T09:49:27.419Z","comments":true,"path":"2021/05/15/简述cookie session和token/","link":"","permalink":"http://example.com/2021/05/15/%E7%AE%80%E8%BF%B0cookie%20session%E5%92%8Ctoken/","excerpt":"","text":"tokentoken的引入：token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token便应运而生。token的定义：token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个token便将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。使用token的目的：使用token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。 cookie会话（session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是cookie与session。cookie通过在客户端记录信息确定用户身份，session通过在服务器端记录信息确定用户身份。 由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是cookie的工作原理。 cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该cookie一同提交给服务器。服务器检查该cookie，以此来辨认用户状态。服务器还可以根据需要修改cookie的内容。 sessionsession是另一种记录客户状态的机制，不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 如果说cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 总结token：服务端生成并返回给客户端的一串字符串，客户端只需带上token来请求数据，无需再次带上用户名和密码。这样一来服务端就不用频繁查询用户名和密码用于验证，有助于减轻服务端压力cookie：由服务端发送给客户端，客户端请求时带上cookie，服务端就可以通过cookie来识别客户端身份了session：存储在服务端，保存的是客户端的状态相关数据","categories":[],"tags":[]},{"title":"ES5和ES6中的继承","slug":"ES5和-ES6中的继承","date":"2021-05-05T07:30:37.000Z","updated":"2021-05-07T05:58:54.827Z","comments":true,"path":"2021/05/05/ES5和-ES6中的继承/","link":"","permalink":"http://example.com/2021/05/05/ES5%E5%92%8C-ES6%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"","text":"在ES5中是利用构造函数的形式来实现面向对象的，ES6新增了类（class）的概念，是ES5中构造函数形式的语法糖，其本质也是函数以下分别是ES5和ES6中的继承例子： ES5中的继承ES5中的继承有多种方式，这里以组合继承为例 123456789101112131415161718192021222324252627// 父类function Father(name) &#123; this.name = name; this.colors = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;purple&#x27;];&#125;// 父类的函数Father.prototype.sayName = function () &#123; console.log(this.name);&#125;Father.prototype.showHobby = function () &#123; console.log(&#x27;my hobby is watching TV&#x27;);&#125;// 子类function Son(name, age) &#123; // 继承父类的name属性 Father.call(this, name); // 定义子类自己的属性age this.age = age;&#125;// 继承父类的方法Son.prototype = new Father();Son.prototype.constructor = Son;// 定义自己的方法Son.prototype.sayAge = function () &#123; console.log(this.age);&#125; ES6中的继承123456789101112131415161718192021222324252627class Father &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHi() &#123; console.log(&#x27;hello I am &#x27; + this.name); &#125; say() &#123; return &#x27;我是父亲&#x27;; &#125;&#125;class Son extends Father &#123; constructor(name, age, hobby) &#123; // super实现继承父类构造函数 super(name, age); // 子类独有的属性hobby，需要单独写 this.hobby = hobby; &#125; sayHi() &#123; // super调用父类普通函数 console.log(super.say() + &#x27;的儿子&#x27;); console.log(&#x27;hello, my name is &#x27; + this.name); &#125;&#125;","categories":[],"tags":[]},{"title":"简述JS浅拷贝和深拷贝","slug":"简述JS浅拷贝和深拷贝","date":"2021-05-03T01:55:05.000Z","updated":"2021-05-03T02:33:14.891Z","comments":true,"path":"2021/05/03/简述JS浅拷贝和深拷贝/","link":"","permalink":"http://example.com/2021/05/03/%E7%AE%80%E8%BF%B0JS%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"数据类型 基本数据类型数据直接存储到栈中 引用数据类型数据的引用存放在栈中，真实的数据存放在堆内存中 浅拷贝和深拷贝浅拷贝和深拷贝是只针对引用数据类型而言的，基本数据类型无所谓浅拷贝和深拷贝 浅拷贝当两个引用数据类型浅拷贝时，拷贝的只是引用，改变其中一个数据的值，另一个也会随之改变。两个数据的变化是联动的。 深拷贝创建另一个一摸一样的对象，新对象和原来的对象不共享内存，两个对象数据的变化不会联动 深拷贝实现1234567891011121314151617181920212223242526272829303132333435//数组深拷贝示例let arr = [&#x27;javascript&#x27;, &#x27;python&#x27;, &#x27;typescript&#x27;, &#x27;c&#x27;];let arr2 = [...arr];arr2[1] = &#x27;java&#x27;;console.log(arr);//[ &#x27;javascript&#x27;, &#x27;python&#x27;, &#x27;typescript&#x27;, &#x27;c&#x27; ]console.log(arr2);//[ &#x27;javascript&#x27;, &#x27;java&#x27;, &#x27;typescript&#x27;, &#x27;c&#x27; ]//对象深拷贝示例let obj = &#123; name: &#x27;xutangxin&#x27;, age: 22&#125;//深拷贝函数const deepCopy = (sourceObj) =&gt; &#123; const targetObj = Array.isArray(sourceObj) ? [] : &#123;&#125;; for (let key in sourceObj) &#123; if (sourceObj.hasOwnProperty(key)) &#123; //如果是引用类型，就递归复制 if (sourceObj[key] &amp;&amp; typeof sourceObj[key] === &#x27;object&#x27;) &#123; targetObj[key] = deepCopy(sourceObj[key]); &#125; else &#123; //如果是简单数据类型，就直接复制 targetObj[key] = sourceObj[key]; &#125; &#125; &#125; return targetObj;&#125;let obj2 = deepCopy(obj);console.log(obj, obj2);//&#123; name: &#x27;xutangxin&#x27;, age: 22 &#125; &#123; name: &#x27;xutangxin&#x27;, age: 22 &#125;obj2.name = &#x27;xuhu&#x27;;console.log(obj, obj2);//&#123; name: &#x27;xutangxin&#x27;, age: 22 &#125; &#123; name: &#x27;xuhu&#x27;, age: 22 &#125;","categories":[],"tags":[]},{"title":"JS 反转数组的几种方法","slug":"JS-反转数组的几种方法","date":"2021-05-03T01:50:04.000Z","updated":"2021-05-03T01:50:33.630Z","comments":true,"path":"2021/05/03/JS-反转数组的几种方法/","link":"","permalink":"http://example.com/2021/05/03/JS-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122let arr = [1, 2, 3, 4, 5];// 方法1，影响原数组// console.log(arr.reverse());// 方法2，不影响原数组let reverseArr = arr.slice().reverse();console.log(arr);console.log(reverseArr);// 方法3，不影响原数组let reverseArr2 = [...arr].reverse();console.log(arr);console.log(reverseArr2);// 方法4，不使用reverse实现反转数组let reverseArr3 = [];for (let i = arr.length - 1; i &gt;= 0; i--) &#123; reverseArr3.push(arr[i]);&#125;console.log(arr);console.log(reverseArr3);","categories":[],"tags":[]},{"title":"简述函数节流和防抖","slug":"简述函数节流和防抖","date":"2021-05-02T12:40:05.000Z","updated":"2021-05-02T13:02:01.307Z","comments":true,"path":"2021/05/02/简述函数节流和防抖/","link":"","permalink":"http://example.com/2021/05/02/%E7%AE%80%E8%BF%B0%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/","excerpt":"","text":"为什么需要函数节流和防抖频繁执行dom操作，资源加载等行为，可能会导致UI卡顿或浏览器崩溃如果每次执行事件就会触发函数，这样的做法不仅没有意义，还会浪费资源 函数节流每隔一定的时间才能调用函数，而不是每次触发事件就执行一次，这样会减少资源的浪费（连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。） 函数防抖当事件触发完一定时间后，在这个时间间隔内没有事件再次触发，就认为该事件触发完成了，此时可以执行函数（触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。） 代码示例html: 12&lt;button id=&quot;btn&quot;&gt;节流&lt;/button&gt;&lt;button id=&quot;btn2&quot;&gt;防抖&lt;/button&gt; js: 12345678910111213141516171819202122232425262728293031323334353637//定义节流函数function Throttle(fn, delay) &#123; let lastTime = 0; return function () &#123;//为什么要用闭包？ let nowTime = Date.now(); if (nowTime - lastTime &gt; delay) &#123; fn.apply(this);//使用apply保证this指向正确 lastTime = Date.now(); &#125; &#125;&#125;//定义被节流的函数function fn() &#123; console.log(&#x27;节流&#x27;);&#125;//响应事件，触发节流函数btn.onclick = Throttle(fn, 1000);// 定义防抖函数function debounce(fn, delay) &#123; let timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this) &#125;,delay); &#125;&#125;//定义被防抖的函数function fn2()&#123; console.log(&#x27;防抖&#x27;);&#125;//响应事件，触发防抖函数document.querySelector(&#x27;#btn2&#x27;).onclick=debounce(fn2,3000);","categories":[],"tags":[]},{"title":"JS 数组去重的几种方法","slug":"JS-数组去重的几种方法","date":"2021-05-01T08:47:54.000Z","updated":"2021-05-02T13:02:09.457Z","comments":true,"path":"2021/05/01/JS-数组去重的几种方法/","link":"","permalink":"http://example.com/2021/05/01/JS-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031// let arr=[1,2,3,3,3,4,4,5];let arr=[0,0,1,1,1,2,2,3,3,4];// 方法1 最简单let newArr=[...new Set(arr)];console.log(newArr);// 方法2 使用indexOflet newArr2=[];for(let i=0;i&lt;arr.length;i++)&#123; if(newArr2.indexOf(arr[i])===-1)&#123; newArr2.push(arr[i]); &#125;&#125;console.log(newArr2);// 方法3 使用includeslet newArr3=[];for(let i=0;i&lt;arr.length;i++)&#123; if(!newArr3.includes(arr[i]))&#123; newArr3.push(arr[i]); &#125;&#125;console.log(newArr3);// 方法4 使用filterlet newArr4=arr.filter((item,index,arr)=&gt;&#123; // 当前元素在原始数组中的第一个索引===当前索引值 return arr.indexOf(item,0)===index;&#125;);console.log(newArr4);","categories":[],"tags":[]},{"title":"JS中==和===的区别","slug":"JS中-和-的区别","date":"2021-04-17T04:10:09.000Z","updated":"2021-05-03T02:14:26.572Z","comments":true,"path":"2021/04/17/JS中-和-的区别/","link":"","permalink":"http://example.com/2021/04/17/JS%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"总的来说：==判断相等，===判断严格相等/全等==只判断数据的值是否相等，===先判断数据的类型是否相同，再判断数据的值是否相等 ==判断规则：两个基本数据类型比较：如果两个基本数据类型不同，会先把它们转换成数值类型，再进行比较基本数据类型和引用数据类型比较：先把对象转换成原始值，再按照以上规则进行比较两个引用类型比较：判断两者的引用地址是否相同NaN不等于任何操作数，甚至不等于它自身特殊情况：1234null == undefined//trueNaN != NaN//trueundefined == 0//falsenull == 0//false ===判断规则：先判断两者类型，只要类型不一致，直接返回false，类型相同的前提下，再判断值是否相等 尽量使用===，因为==不严谨","categories":[],"tags":[]},{"title":"JS中的变量类型转换","slug":"JS中变量类型隐式转换","date":"2021-04-17T04:01:23.000Z","updated":"2021-05-03T02:31:56.819Z","comments":true,"path":"2021/04/17/JS中变量类型隐式转换/","link":"","permalink":"http://example.com/2021/04/17/JS%E4%B8%AD%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"可能会出现类型转换的情况： if语句 逻辑语句 数学运算当数字和字符串相加时，js会把数字转换为字符串，然后拼接 ==详情参见’JS中==和===的区别’特殊情况：null==undefined结果为true","categories":[],"tags":[]}],"categories":[],"tags":[]}